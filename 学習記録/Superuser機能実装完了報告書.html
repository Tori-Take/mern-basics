<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スーパー管理者機能実装 完了報告</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: #212529;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 20px;
            background-color: #f9fbfd;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 50px;
        }

        h1 {
            text-align: center;
            border-bottom-width: 5px;
            font-size: 3em;
            color: #1a5276;
        }

        h2 {
            font-size: 2.2em;
            border-left: 8px solid #3498db;
            background-color: #ecf5fb;
            padding: 10px 15px;
        }

        pre {
            background-color: #283747;
            color: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 1em;
            line-height: 1.6;
        }

        code {
            background-color: #e9ecef;
            padding: 3px 7px;
            border-radius: 5px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            color: #c7254e;
        }

        .card {
            background-color: #fff;
            border: 1px solid #d6eaf8;
            border-radius: 10px;
            padding: 35px;
            margin-bottom: 35px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.07);
        }

        .pass {
            color: #27ae60;
            font-weight: bold;
        }

        .fail {
            color: #c0392b;
            font-weight: bold;
        }

        .debug-story {
            background-color: #fef9e7;
            border-left: 5px solid #f39c12;
            padding: 25px;
            margin-top: 30px;
            border-radius: 8px;
        }

        .debug-story h3 {
            color: #b7791f;
            border-bottom-color: #f39c12;
        }

        .final-message {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #1a5276;
            padding: 30px;
            background-color: #eafaf1;
            border-radius: 10px;
            border: 2px dashed #2ecc71;
        }
    </style>
</head>

<body>

    <h1>スーパー管理者機能実装 完了報告</h1>
    <p style="text-align: center; font-size: 1.2em; color: #566573;">バックエンド編：堅牢な権限管理システムの構築</p>

    <div class="card">
        <h2>はじめに</h2>
        <p>
            本開発では、アプリケーションに「スーパー管理者（Superuser）」という最上位の権限を導入し、システム全体を管理するための専用APIをバックエンドに実装しました。
            この実装は、クリーンアーキテクチャの原則に則り、変更に強く、テスト容易性の高いコードで実現されています。
        </p>
        <p>
            特に、実装の最終段階である結合テストでは、困難なデバッグに直面しました。しかし、粘り強い問題解決の末にこれを乗り越え、極めて信頼性の高いバックエンド機能を完成させることができました。このドキュメントは、その実装の軌跡と、デバッグから得られた貴重な学びを記録するものです。
        </p>
    </div>

    <div class="card">
        <h2>実装のハイライト</h2>
        <ol>
            <li><strong>Superuser権限ミドルウェアの実装:</strong> <code>core/middleware/superuser.js</code>
                を作成し、APIリクエストがスーパー管理者からのものであるかを検証する「門番」を設置しました。</li>
            <li><strong>専用APIドメインの構築:</strong> システム管理機能を集約する <code>domains/system/</code>
                を新設。テナントの一覧取得や削除といった、強力な権限を要するAPIを実装しました。</li>
            <li><strong>サービスロジックの実装:</strong> テナントを削除する際に、そのテナントに所属する全てのユーザーも同時に削除するという、複雑なビジネスロジックを
                <code>system.service.js</code> にカプセル化しました。</li>
            <li><strong><span class="pass">結合テストの成功:</span></strong> スーパー管理者と一般管理者の権限の違いを網羅的に検証する結合テスト
                (<code>system.routes.test.js</code>) を作成し、APIが期待通りに動作することを保証しました。</li>
        </ol>

        <div class="debug-story">
            <h3>デバッグの物語：<code>TypeError: *.generateToken is not a function</code> との戦い</h3>
            <p>
                今回の開発で最大の壁となったのが、テストコードで繰り返し発生した <code>TypeError</code>
                でした。このエラーは、単純な構文ミスではなく、テストの実行サイクル、変数のスコープ、そしてアーキテクチャへの深い理解を問う、非常に根深い問題でした。
            </p>
            <h4>私たちが辿った道のり：</h4>
            <ul>
                <li><strong>仮説① 変数のスコープ問題:</strong> <code>let</code>で宣言した変数が、関数内で再宣言されているのでは？ → 修正するも解決せず。</li>
                <li><strong>仮説② テスト間の状態汚染:</strong> <code>afterEach</code>でのDBクリアが、次のテストに影響しているのでは？ →
                    <code>beforeEach</code>で変数をリセットするも解決せず。</li>
                <li><strong>仮説③ Mongooseオブジェクトの変質:</strong> <code>save()</code>後のオブジェクトが、メソッドを失っているのでは？ →
                    <code>findById()</code>で再取得するも解決せず。</li>
                <li><strong>仮説④ Jestの実行順序:</strong> 複数の<code>describe</code>ブロックが予期せぬ順序で実行されているのでは？ →
                    構造をリファクタリングするも解決せず。</li>
            </ul>
            <p>
                私たちは<code>console.log</code>を駆使し、エラー発生直前の変数の型を執拗に追跡しました。その結果、変数は常に正しいMongooseモデルのインスタンスであることが判明。これにより、これまでの仮説がすべて覆され、私たちは思考の振り出しに戻りました。
            </p>
            <h4>ブレークスルー：根本的な誤解の発見</h4>
            <p>
                ログが「変数は正しい」と告げているのに、なぜエラーが起きるのか？<br>
                ここで私たちは、最も基本的な問いに立ち返りました。<strong>「そもそも、<code>User</code>モデルのインスタンスに<code>generateToken</code>というメソッドは存在するのか？」</strong>
            </p>
            <p>
                答えは「No」でした。<code>generateToken</code>は、<code>user.model.js</code>に定義されたインスタンスメソッドではなく、<code>core/utils/generateToken.js</code>に定義された<strong>独立したユーティリティ関数</strong>だったのです。
            </p>
            <p>
                テストコードで<code>superuser.generateToken()</code>と呼び出していたこと自体が、アーキテクチャの設計思想との根本的なズレでした。正しい呼び出し方は<code>generateToken(superuser._id)</code>だったのです。この事実に気づいた瞬間、長かったデバッグのトンネルに、ようやく光が差し込みました。
            </p>
        </div>
    </div>

    <div class="card">
        <h2>得られた知見と最終的なコード</h2>
        <p>
            この困難なデバッグを通じて、私たちは技術的なスキル以上の、極めて重要な教訓を得ました。
        </p>
        <ul>
            <li><strong>ドキュメントと実装を信じる:</strong>
                アーキテクチャ図（<code>フルスタック近代化完了報告.html</code>）には、<code>generateToken.js</code>は<code>core/utils</code>に属する汎用関数として明確に記載されていました。行き詰まった時こそ、基本に立ち返り、設計ドキュメントを再確認することの重要性を痛感しました。
            </li>
            <li><strong>仮説と検証のサイクル:</strong>
                <code>console.log</code>による地道な検証作業がなければ、私たちは永遠にスコープや状態汚染の問題を疑い続けていたかもしれません。事実（ログ）に基づいて仮説を一つずつ潰していく、科学的なアプローチが問題解決の鍵でした。
            </li>
            <li><strong>「なぜ」を問い続ける粘り強さ:</strong> 「動かない」という現象の裏にある「なぜ動かないのか」という本質的な原因を追求し続けたことが、最終的なブレークスルーに繋がりました。</li>
        </ul>
        <h3>最終的なテストコード</h3>
        <p>数々の戦いを乗り越えて完成した、クリーンで堅牢なテストコードです。</p>
        <pre>
// c:/Users/Tori-Take/Desktop/mern-basics/server/domains/system/__tests__/system.routes.test.js

const request = require('supertest');
const mongoose = require('mongoose');
const app = require('../../../app');
const { connectDB, disconnectDB, clearDB } = require('../../../core/config/db.memory');
const generateToken = require('../../../core/utils/generateToken'); // ★ 正しくユーティリティをインポート
const User = require('../../identity/user.model');
const Tenant = require('../../organization/tenant.model');

describe('Superuser System Routes', () => {
  // (beforeAll, afterEach, afterAllフックは省略)

  let superuserToken, adminToken;
  let superuser, adminUser;

  const setupUsersAndTokens = async () => {
    // ... ユーザーとテナントの作成処理 ...
    const newSuperuser = new User({...});
    await newSuperuser.save();
    const newAdminUser = new User({...});
    await newAdminUser.save();

    superuser = await User.findById(newSuperuser._id);
    adminUser = await User.findById(newAdminUser._id);

    // ★★★ 正しい呼び出し方 ★★★
    superuserToken = generateToken(superuser._id);
    adminToken = generateToken(adminUser._id);
  };

  describe('System API Access Control', () => {
    beforeEach(async () => {
      await setupUsersAndTokens();
    });

    // ... it ブロック (テストケース) ...
  });
});
        </pre>
    </div>

    <div class="final-message">
        バックエンド開発完了！<br>
        この強固な土台の上に、次はフロントエンドを構築していきましょう！
    </div>

</body>

</html>