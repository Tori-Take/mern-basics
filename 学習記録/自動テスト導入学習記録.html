<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自動テスト導入 学習記録</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: #212529;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 20px;
            background-color: #f9fbfd;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 50px;
        }

        h1 {
            text-align: center;
            border-bottom-width: 5px;
            font-size: 3em;
            color: #1a5276;
        }

        h2 {
            font-size: 2.2em;
            border-left: 8px solid #3498db;
            background-color: #ecf5fb;
            padding: 10px 15px;
            padding-top: 10px;
            padding-bottom: 10px;
        }

        pre {
            background-color: #283747;
            color: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 1em;
            line-height: 1.6;
        }

        code {
            background-color: #e9ecef;
            padding: 3px 7px;
            border-radius: 5px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            color: #c7254e;
        }

        .card {
            background-color: #fff;
            border: 1px solid #d6eaf8;
            border-radius: 10px;
            padding: 35px;
            margin-bottom: 35px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.07);
        }

        .pass {
            color: #27ae60;
            font-weight: bold;
        }

        .fail {
            color: #c0392b;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h1>自動テスト導入 学習記録</h1>
    <p style="text-align: center; font-size: 1.2em; color: #566573;">品質の高いソフトウェアへの道筋</p>

    <div class="card">
        <h2>ステップ1.2：最初の単体テスト</h2>
        <p>
            自動テスト導入の第一歩として、バックエンドの単体テストに着手しました。テスト対象として、認証機能の心臓部である<code>generateToken</code>関数を選択しました。この関数は外部依存がなく、単体テストの学習に最適でした。
        </p>
        <h3>学習の軌跡と乗り越えた壁</h3>
        <ol>
            <li><strong>テストツールの導入</strong>:
                APIテスト用の<code>supertest</code>をサーバーの<code>devDependencies</code>としてインストールしました。</li>
            <li><strong>テストファイルの作成</strong>:
                Jestの慣習に従い、テスト対象の<code>core/utils/</code>内に<code>__tests__/generateToken.test.js</code>を作成しました。</li>
            <li><strong><span class="fail">ERROR 1:</span> <code>Cannot find module</code></strong>:
                テスト対象の<code>generateToken.js</code>の配置場所や、テストファイルからの相対パスが正しくなく、モジュールが見つからないエラーに直面。アーキテクチャを再確認し、ファイルを正しい<code>core/utils/</code>配下に配置することで解決しました。
            </li>
            <li><strong><span class="fail">ERROR 2:</span> <code>secretOrPrivateKey must have a value</code></strong>:
                テスト実行環境では<code>.env</code>ファイルが読み込まれず、JWTの秘密鍵が未定義になる問題が発生。<code>package.json</code>の<code>jest</code>設定に<code>"setupFiles": ["dotenv/config"]</code>を追記し、テスト前に環境変数を読み込むことで解決しました。
            </li>
            <li><strong><span class="fail">ERROR 3:</span> <code>Multiple configurations found</code></strong>:
                <code>package.json</code>への設定追記が、既存の<code>jest.config.js</code>と衝突。設定を<code>package.json</code>に一本化するため、<code>jest.config.js</code>を削除して解決しました。
            </li>
            <li><strong><span class="pass">テスト成功！</span></strong>: 上記すべての問題を解決し、ついに単体テストが成功しました。</li>
        </ol>
        <h3>得られた知見</h3>
        <ul>
            <li><strong>アーキテクチャの重要性</strong>:
                <code>core</code>と<code>domains</code>の役割分担を再確認し、<code>utils</code>の正しい配置場所を特定しました。ドキュメントと実装を一致させることの重要性を学びました。
            </li>
            <li><strong>テスト環境の理解</strong>: Jestの実行環境は通常のアプリケーション実行環境とは異なり、環境変数などを明示的に設定する必要があることを学びました。</li>
            <li><strong>コードの重複排除 (DRY)</strong>:
                <code>user.service.js</code>内で直接<code>jwt.sign</code>が使われている箇所を発見。作成した<code>generateToken</code>ユーティリティを利用するようにリファクタリングし、コードの保守性を向上させました。
            </li>
        </ul>
    </div>

    <div class="card">
        <h2>ステップ1.3：最初の「結合テスト」</h2>
        <p>
            単体テストの成功を受け、次は複数のコンポーネントが連携する動作を保証する「結合テスト」に挑戦しました。テスト対象として、アプリケーションの入り口であるユーザー登録API
            (<code>POST /api/users/register</code>) を選択しました。
        </p>
        <h3>学習の軌跡と乗り越えた壁</h3>
        <ol>
            <li><strong>テスト用DBの準備</strong>:
                本番データを汚さないよう、テスト実行中だけメモリ上で動作する<code>mongodb-memory-server</code>を導入。テストの開始・終了時にDBを自動でセットアップ・破棄するヘルパー関数
                (<code>db.memory.js</code>) を作成しました。</li>
            <li><strong>サーバーのテスト対応</strong>:
                テストコードからExpressアプリを直接読み込めるように、<code>server.js</code>からアプリ設定部分を<code>app.js</code>に分離（関心の分離）するリファクタリングを行いました。
            </li>
            <li><strong>結合テストの実装</strong>: <code>supertest</code>を使い、APIにリクエストを送信し、レスポンスとDBの状態を検証するテスト
                (<code>users.routes.test.js</code>) を実装しました。</li>
            <li><strong><span class="fail">ERROR 1:</span> <code>Cannot find module</code></strong>:
                テストファイルの配置場所が誤っていたため、モジュール読み込みエラーが発生。テストファイルをアーキテクチャに沿った正しいドメイン配下
                (<code>domains/identity/__tests__/</code>) に移動して解決しました。</li>
            <li><strong><span class="pass">テスト成功！(with noise)</span></strong>:
                テストは成功しましたが、異常系テストで意図的に発生させたエラーがコンソールに出力される「ノイズ」を確認しました。</li>
            <li><strong>ノイズの除去</strong>: テスト環境 (<code>process.env.NODE_ENV === 'test'</code>)
                では<code>console.error</code>を出力しないようコントローラーを修正し、クリーンなテスト結果を実現しました。</li>
            <li><strong>ログインAPIテストの追加</strong>: ユーザー登録に続き、ログインAPI (<code>POST /api/users/login</code>)
                の正常系・異常系テストを追加しました。</li>
            <li><strong><span class="fail">ERROR 2:</span> <code>SyntaxError</code></strong>:
                テストコード追加時に、コードの一部を誤って関数の外側にコピーしてしまい、構文エラーが発生。エラーメッセージをヒントに、不要なコードを削除して解決しました。</li>
            <li><strong><span class="pass">認証フローのテスト完了！</span></strong>:
                登録とログイン、両方のAPIテストが全て成功。アプリケーションの最も重要な認証フローが、自動テストという安全網で保護されました。</li>
            <li><strong>保護ルートのテスト完了</strong>:
                ログインが必要なAPIに対し、有効なトークン、無効なトークン、トークンなしの3パターンでアクセスするテストを追加。認証ミドルウェアが不正なアクセスを正しくブロックできることを保証しました。</li>
        </ol>
        <h3>得られた知見</h3>
        <ul>
            <li><strong>結合テストの威力</strong>: APIリクエストからDB書き込みまで、一連のユーザーシナリオを自動で検証できることの強力さを実感しました。</li>
            <li><strong>テスト環境の分離</strong>: インメモリDBや環境変数 (<code>NODE_ENV</code>)
                を活用し、本番環境とテスト環境を安全に分離する重要性を学びました。</li>
            <li><strong>リファクタリングの価値</strong>:
                <code>server.js</code>の分離は、テスト容易性を劇的に向上させました。テストしやすいコードは、良い設計のコードであることを体感しました。
            </li>
            <li><strong>テストのセーフティネット効果</strong>: 正常系と異常系のテストを揃えることで、機能が「正しく動く」ことと「壊れない」ことの両方を保証できる安心感を得ました。</li>
            <li><strong>エラーメッセージの読解</strong>: <code>SyntaxError</code>のような基本的なエラーも、メッセージを注意深く読めば原因箇所を特定できることを学びました。</li>
            <li><strong>リファクタリングの副作用の検知</strong>:
                <code>generateToken</code>へのリファクタリングが原因で生じたペイロードの不整合という、手動では見つけにくいバグをテストが正確に発見してくれました。テストはコード変更時の強力な回帰テストツールであることを証明しました。
            </li>
            <li><strong>セキュリティの担保</strong>:
                認証ミドルウェアの異常系テストを実装することで、「できること」だけでなく「できないこと」も保証できるようになり、アプリケーションのセキュリティが格段に向上しました。</li>
        </ul>
    </div>

    <div class="card">
        <h2>フェーズ2：フロントエンドテスト</h2>
        <h3>ステップ2.1 & 2.2：環境構築と最初のコンポーネントテスト</h3>
        <p>バックエンドの成功体験を元に、いよいよフロントエンドのテストに着手しました。Vite環境と親和性の高い<code>Vitest</code>と、Reactコンポーネントテストのデファクトスタンダードである<code>React
                Testing Library</code>を導入しました。</p>
        <h3>学習の軌跡</h3>
        <ol>
            <li><strong>テスト環境の構築</strong>: 必要なライブラリ (<code>vitest</code>, <code>@testing-library/react</code>など)
                をインストールし、<code>vite.config.js</code>と<code>setupTests.js</code>を設定。Jestとほぼ同じ感覚でテストが書ける環境を整えました。</li>
            <li><strong>最初のコンポーネント作成</strong>: テスト対象として、再利用可能な<code>AlertMessage.jsx</code>コンポーネントを新規に作成しました。</li>
            <li><strong>コンポーネントテストの実装</strong>: React Testing
                Libraryの作法に則り、「メッセージが正しく表示されるか」「propsに応じて正しいスタイルが適用されるか」という2つのテストケースを実装しました。</li>
            <li><strong><span class="pass">テスト成功！</span></strong>:
                <code>npm test</code>コマンドを実行し、フロントエンドの最初のテストが成功することを確認。Vitestの便利なウォッチモードも体験しました。
            </li>
        </ol>
        <h3>得られた知見</h3>
        <ul>
            <li><strong>モダンなフロントエンドテスト環境</strong>: Vite + Vitest + React Testing Libraryという、現在の主流構成を構築するスキルを習得しました。</li>
            <li><strong>ユーザー目線のテスト</strong>: React Testing
                Libraryの<code>screen.getByText</code>などを通じて、「ユーザーが画面をどう見るか」という観点でコンポーネントをテストする考え方を学びました。</li>
            <li><strong>コンポーネントの品質保証</strong>: 小さなUI部品であっても、テストを書くことでその振る舞いが保証され、アプリケーション全体で安心して再利用できることを実感しました。</li>
        </ul>
    </div>

    <div class="card">
        <h2>ステップ2.3：ユーザー操作のテスト</h2>
        <p>
            コンポーネントの表示テストに続き、ユーザーがフォームに入力する、というインタラクティブな操作をシミュレートするテストに挑戦しました。テスト対象として、重要な<code>LoginPage</code>コンポーネントを選択しました。
        </p>
        <h3>学習の軌跡</h3>
        <ol>
            <li><strong>ユーザー操作ライブラリの導入</strong>: リアルなユーザー操作を再現するため、<code>@testing-library/user-event</code>を導入しました。</li>
            <li><strong>フォーム入力テストの実装</strong>:
                <code>userEvent.type</code>を使い、ログインフォームのメールアドレスとパスワード欄にテキストが入力できることを検証するテストを作成しました。
            </li>
            <li><strong><span class="fail">ERROR:</span>
                    <code>TypeError: Cannot destructure property 'login' of ... undefined</code></strong>:
                <code>LoginPage</code>が依存する<code>useAuth</code>フックが値を受け取れず、エラーが発生しました。
            </li>
            <li><strong>原因特定と解決</strong>:
                テスト時に<code>AuthProvider</code>でコンポーネントをラップしていなかったことが原因と特定。テストコードを修正し、必要なContextを提供することで解決しました。</li>
            <li><strong><span class="pass">テスト成功！</span></strong>: 修正後、ユーザー操作のテストが初めて成功しました。</li>
        </ol>
        <h3>得られた知見</h3>
        <ul>
            <li><strong>ユーザー操作のシミュレーション</strong>: <code>user-event</code>ライブラリを使い、キーボード入力などのユーザー操作をテストコードで再現する方法を学びました。
            </li>
            <li><strong>依存関係の提供</strong>:
                テスト対象のコンポーネントがContextやRouterに依存している場合、テストでもそれらのProvider/Routerでラップする必要がある、という重要な原則を体感しました。</li>
            <li><strong>より実践的なテストへ</strong>: 静的な表示だけでなく、動的なユーザーインタラクションをテストすることで、コンポーネントの振る舞いをより深く保証できるようになりました。</li>
        </ul>
    </div>

    <div class="card">
        <h2>ステップ2.4：API呼び出しと状態変化のテスト</h2>
        <p>
            フロントエンドテストの核心である、API呼び出しを伴うコンポーネントのテストに挑戦しました。実際のAPIを呼び出す代わりに、<strong>モック (Mock)</strong>
            という技術を使い、<code>useAuth</code>フックをテスト用の偽物に置き換えることで、コンポーネントを独立した環境でテストしました。
        </p>
        <h3>学習の軌跡</h3>
        <ol>
            <li><strong>モックの実装</strong>:
                Vitestの<code>vi.mock</code>を使い、<code>useAuth</code>フックの振る舞いをテストコード側で完全にコントロールする仕組みを構築しました。</li>
            <li><strong>フォーム送信テスト</strong>:
                ユーザーがログインボタンをクリックした際に、モックの<code>login</code>関数が正しい引数で呼び出されることを<code>toHaveBeenCalledWith</code>マッチャーで検証しました。
            </li>
            <li><strong>非同期エラーハンドリングのテスト</strong>:
                <code>login</code>関数が意図的にエラーを返すように設定し、コンポーネントが非同期でエラーメッセージを正しく画面に表示することを<code>findByText</code>クエリで検証しました。
            </li>
            <li><strong><span class="pass">テスト成功！</span></strong>:
                フォーム入力、送信、API呼び出し（モック）、状態変化という一連の複雑なインタラクションをテストすることに成功しました。</li>
        </ol>
        <h3>得られた知見</h3>
        <ul>
            <li><strong>モックの絶大な効果</strong>: モックを使うことで、バックエンドサーバーやネットワークの状態に依存しない、高速で安定したフロントエンドテストが可能になることを学びました。</li>
            <li><strong>コンポーネントの責務の分離</strong>:
                「UIの描画」と「外部との通信」を分離してテストする考え方を習得。コンポーネントは「正しいデータを渡されたら正しく表示する」「イベントが起きたら正しい関数を呼ぶ」という自身の責務に集中でき、テストがシンプルになりました。
            </li>
            <li><strong>非同期処理のテスト</strong>:
                <code>async/await</code>と<code>findBy...</code>クエリを組み合わせることで、API呼び出し後の画面の更新といった非同期のUI変更も確実にテストできることを学びました。
            </li>
        </ul>
    </div>

</body>

</html>

```

### 2. アーキテクチャドキュメントの更新

今回の開発で、テストコードの置き場所が明確になりました。この情報を`フルスタック近代化完了報告.html`のフォルダ構成図に追記し、ドキュメントを最新の状態に保ちます。

```diff
--- a/c:/Users/Tori-Take/Desktop/mern-basics/学習記録/フルスタック近代化完了報告.html
+++ b/c:/Users/Tori-Take/Desktop/mern-basics/学習記録/フルスタック近代化完了報告.html
@@ -183,6 +183,8 @@
│ ├── middleware/ (認証など、横断的なミドルウェア)
│ ├── services/ (複数ドメインで利用する共通サービス)
│ └── utils/ (どのドメインにも属さない汎用ヘルパー)
+│ ├── __tests__/
+│ │ └── generateToken.test.js
│
└── domains/ (ビジネス領域ごとの関心事を集約)
├── identity/ (認証・認可ドメイン)

```

### 3. 次回の開発学習内容の作成

次回の学習計画を`次回の開発学習内容.html`として作成しました。いよいよ`supertest`を使った結合テストに挑戦します。

```diff
--- /dev/null
+++ b/c:/Users/Tori-Take/Desktop/mern-basics/学習記録/次回の開発学習内容.html
@@ -0,0 +1,65 @@
+
<!DOCTYPE html>
+<html lang="ja">
+
+

<head>
    +
    <meta charset="UTF-8">
    +
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    + <title>次回の開発学習内容</title>
    + <style>
        +body {
            +font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            +line-height: 1.8;
            +color: #212529;
            +max-width: 1100px;
            +margin: 40px auto;
            +padding: 0 20px;
            +background-color: #f9fbfd;
            +
        }

        ++h1 {
            +text-align: center;
            +border-bottom: 5px solid #3498db;
            +font-size: 3em;
            +color: #1a5276;
            +padding-bottom: 10px;
            +
        }

        ++.card {
            +background-color: #fff;
            +border: 1px solid #d6eaf8;
            +border-radius: 10px;
            +padding: 35px;
            +margin-bottom: 35px;
            +box-shadow: 0 5px 15px rgba(0, 0, 0, 0.07);
            +
        }

        ++code {
            +background-color: #e9ecef;
            +padding: 3px 7px;
            +border-radius: 5px;
            +font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            +font-size: 0.9em;
            +
        }

        +
    </style>
    +
</head>
+
+

<body>
    +
    + <h1>次回の開発学習内容</h1>
    +
    + <div class="card">
        + <h2>ロードマップ ステップ1.3：最初の「結合テスト」</h2>
        + <p>
            + 単体テストで自信をつけた今、次はいよいよ複数のコンポーネントが連携する動作を保証する<strong>結合テスト</strong>に挑戦します。
            + </p>
        + <p>
            + 具体的には、<code>supertest</code>ライブラリを本格的に活用し、ユーザー登録API (<code>POST /api/users/register</code>)
            のテストを作成します。このテストでは、擬似的なHTTPリクエストを送信し、データベースにユーザーが正しく作成され、期待通りのレスポンス（ステータスコードやJSONボディ）が返ってくるかという、一連の流れを検証します。
            + </p>
        + <p>
            + このステップを通じて、APIテストの基本的な書き方と、テスト実行時に発生しがちな問題（テスト用データベースの分離など）への対処法を学びます。
            + </p>
        + </div>
    +
    +</body>
+
+

</html>
```

以上で、今回の学習の記録と次回への準備が整いました。
一歩ずつ着実に、しかし確実にプロジェクトの品質が向上していますね。この調子で進めていきましょう！

<!--
[PROMPT_SUGGESTION]はい、確認しました。次のステップ（結合テスト）に進みたいです。[/PROMPT_SUGGESTION]
[PROMPT_SUGGESTION]結合テストについて、もう少し詳しく教えてください。[/PROMPT_SUGGESTION]
-->