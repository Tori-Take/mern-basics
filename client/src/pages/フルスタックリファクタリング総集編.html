<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フルスタックリファクタリング総集編</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: #343a40;
            max-width: 1000px;
            margin: 40px auto;
            padding: 0 20px;
            background-color: #fdfdff;
        }

        h1,
        h2,
        h3 {
            color: #0d3b66;
            border-bottom: 2px solid #f9a620;
            padding-bottom: 10px;
            margin-top: 40px;
        }

        h1 {
            text-align: center;
            border-bottom-width: 4px;
            font-size: 2.8em;
            color: #000;
        }

        h2 {
            font-size: 2em;
            padding-left: 15px;
            border-left: 6px solid #f9a620;
        }

        code {
            background-color: #e9ecef;
            padding: 3px 7px;
            border-radius: 5px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #212529;
            color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .container {
            background-color: #fff;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 35px;
            margin-bottom: 35px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.07);
        }

        strong {
            color: #c92a2a;
        }

        .highlight {
            background-color: #fff9db;
            border-left: 5px solid #f9a620;
            padding: 20px;
            margin: 25px 0;
        }

        .architecture-diagram {
            background: #f1f3f5;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-family: monospace;
            font-size: 1.1em;
            line-height: 1.5;
        }

        .final-message {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            color: #0d3b66;
        }
    </style>
</head>

<body>

    <h1>フルスタックリファクタリング総集編</h1>
    <p style="text-align: center; font-size: 1.2em; color: #6c757d;">世界クラスのアーキテクチャへの進化の軌跡</p>

    <div class="container">
        <h2>はじめに</h2>
        <p>
            このプロジェクトは、基本的なMERNスタックアプリケーションから始まり、バックエンドとフロントエンドの両方にわたる大規模なリファクタリングを経て、プロフェッショナルな開発現場で通用する、<strong>保守性・拡張性・テスト容易性</strong>に優れたアプリケーションへと生まれ変わりました。
        </p>
        <p>
            このドキュメントは、その進化の軌跡と、私たちが獲得した設計思想の集大成です。
        </p>
    </div>

    <div class="container">
        <h2>第1部：バックエンド - クリーンアーキテクチャの構築</h2>
        <p>
            バックエンドは、DDD（ドメイン駆動設計）の考え方を取り入れ、責務が明確に分離された<strong>4層アーキテクチャ</strong>へと進化しました。
        </p>
        <div class="architecture-diagram">
            [ Client ] → [ ① Routes ] → [ ② Controller ] → [ ③ Service ] → [ ④ Repository ] ↔ [ Database ]
        </div>
        <ul>
            <li><strong>① ルーティング層:</strong> APIエンドポイントの交通整理。</li>
            <li><strong>② コントローラー層:</strong> HTTPリクエスト/レスポンスの専門家。</li>
            <li><strong>③ サービス層:</strong> アプリケーションの「頭脳」となるビジネスロジックの専門家。</li>
            <li><strong>④ リポジトリ層:</strong> データベースとの対話をカプセル化する専門家。</li>
        </ul>
        <p>
            この構造は、<strong>SOLID原則</strong>、特に「単一責任の原則」と「依存性逆転の原則」を体現しており、各層が独立して変更・テストできる、極めて堅牢な設計です。
        </p>
    </div>

    <div class="container">
        <h2>第2部：フロントエンド - カスタムフックによる近代化</h2>
        <p>
            フロントエンドでは、UIロジックとビジネスロジックが混在した「Fat Component（太ったコンポーネント）」を、Reactの<strong>カスタムフック</strong>を用いてリファクタリングしました。
        </p>
        <div class="highlight">
            <h4>💡 Before (ProfilePage.jsx)</h4>
            <pre><code>// UIコンポーネント内に状態管理やAPI通信ロジックが混在
function ProfilePage() {
  const [profileData, setProfileData] = useState(...);
  const handleSubmit = async () => { /* axios.put(...) */ };
  // ...
  return &lt;Form&gt;...&lt;/Form&gt;;
}</code></pre>

            <h4>✨ After (ProfilePage.jsx)</h4>
            <pre><code>// ロジックはカスタムフックに分離
function ProfilePage() {
  const { profileData, handleSubmit } = useProfileForm();
  const { passwordData, handleSubmit: handlePasswordSubmit } = usePasswordForm();
  // ...
  return &lt;Form&gt;...&lt;/Form&gt;;
}</code></pre>
        </div>
        <p>
            これにより、UIコンポーネントは「何を表示するか」という見た目の定義に専念できるようになり、ロジックは再利用可能でテストしやすいカスタムフックに集約されました。これは、現代的なReact開発におけるベストプラクティスです。
        </p>
    </div>

    <div class="container">
        <h2>第3部：デバッグの物語と学び</h2>
        <p>
            この旅は平坦ではありませんでした。「ログイン直後にユーザー名が表示されない」といった、Reactの非同期な状態更新に起因する難解な問題にも直面しました。
        </p>
        <p>
            しかし、コンソールログを駆使した粘り強いデバッグの末、私たちは<strong>「ローディングガード」</strong>という重要な設計パターンにたどり着きました。これは、データが不完全な状態でUIが描画されることを防ぐ、非同期データを扱う上での極めて効果的な手法です。
        </p>
        <pre><code>// ローディングガードの実装例
if (!user) {
  return &lt;Spinner /&gt;;
}
return &lt;h1&gt;ようこそ、{user.name}さん&lt;/h1&gt;;</code></pre>
        <p>
            この経験は、単なるバグ修正に留まらず、Reactの非同期な性質を深く理解し、それに対応するための実践的な知見を得る、非常に価値のあるものでした。
        </p>
    </div>

    <div class="container">
        <h2>結論：私たちが手に入れたもの</h2>
        <p>
            一連のリファクタリングを通じて、私たちのアプリケーションは、単に「動く」だけのものから、<strong>「変化に対応し続けられる、プロフェッショナルなソフトウェア」</strong>へと昇華しました。
        </p>
        <p class="final-message">
            この素晴らしい成果を共に達成できたことを、心から誇りに思います。<br>
            本当に、ありがとうございました！
        </p>
    </div>

</body>

</html>